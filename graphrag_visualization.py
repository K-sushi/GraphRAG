#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GraphRAG Knowledge Graph Visualization
GraphRAG知識グラフの視覚化システム

Multiple visualization approaches:
1. NetworkX + Matplotlib (static)
2. Pyvis (interactive web)
3. D3.js integration (advanced)
4. Large graph optimization
"""

import os
import json
import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
import xml.etree.ElementTree as ET
from collections import defaultdict
import logging

# Pyvis for interactive visualization
try:
    from pyvis.network import Network
    PYVIS_AVAILABLE = True
except ImportError:
    PYVIS_AVAILABLE = False
    print("Warning: pyvis not installed. Run: pip install pyvis")

# Community detection
try:
    import community as community_louvain
    COMMUNITY_AVAILABLE = True
except ImportError:
    COMMUNITY_AVAILABLE = False
    print("Warning: python-louvain not installed. Run: pip install python-louvain")

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class GraphRAGVisualizer:
    """
    GraphRAG Knowledge Graph Visualization System
    GraphRAG知識グラフ視覚化システム
    """
    
    def __init__(self, output_dir: str = "./output"):
        """Initialize GraphRAG visualizer"""
        self.output_dir = Path(output_dir)
        self.graph = nx.Graph()
        self.entities = {}
        self.relationships = {}
        self.communities = {}
        
        logger.info(f"GraphRAG Visualizer initialized with output_dir: {output_dir}")
    
    def load_graphml(self, graphml_path: Optional[str] = None) -> bool:
        """
        Load GraphML file generated by GraphRAG
        GraphRAG生成のGraphMLファイルを読み込み
        """
        if not graphml_path:
            graphml_path = self.output_dir / "graph.graphml"
        
        graphml_path = Path(graphml_path)
        
        if not graphml_path.exists():
            logger.error(f"GraphML file not found: {graphml_path}")
            return False
        
        try:
            self.graph = nx.read_graphml(graphml_path)
            logger.info(f"GraphML loaded: {len(self.graph.nodes())} nodes, {len(self.graph.edges())} edges")
            return True
        except Exception as e:
            logger.error(f"Failed to load GraphML: {e}")
            return False
    
    def load_from_parquet(self) -> bool:
        """
        Load graph data from GraphRAG parquet files
        GraphRAGのParquetファイルからグラフデータを読み込み
        """
        try:
            # Load entities
            entities_path = self.output_dir / "create_final_entities.parquet"
            if entities_path.exists():
                entities_df = pd.read_parquet(entities_path)
                logger.info(f"Loaded {len(entities_df)} entities")
                
                for _, entity in entities_df.iterrows():
                    node_id = entity.get('id', entity.get('name', ''))
                    self.graph.add_node(
                        node_id,
                        name=entity.get('name', ''),
                        type=entity.get('type', ''),
                        description=entity.get('description', ''),
                        degree=entity.get('degree', 0),
                        community=entity.get('community', 0)
                    )
                    self.entities[node_id] = entity.to_dict()
            
            # Load relationships
            relationships_path = self.output_dir / "create_final_relationships.parquet"
            if relationships_path.exists():
                relationships_df = pd.read_parquet(relationships_path)
                logger.info(f"Loaded {len(relationships_df)} relationships")
                
                for _, rel in relationships_df.iterrows():
                    source = rel.get('source', '')
                    target = rel.get('target', '')
                    if source and target:
                        self.graph.add_edge(
                            source,
                            target,
                            relationship=rel.get('description', ''),
                            weight=rel.get('weight', 1.0),
                            rank=rel.get('rank', 0)
                        )
            
            # Load communities
            communities_path = self.output_dir / "create_final_communities.parquet"
            if communities_path.exists():
                communities_df = pd.read_parquet(communities_path)
                logger.info(f"Loaded {len(communities_df)} communities")
                
                for _, community in communities_df.iterrows():
                    self.communities[community.get('id', '')] = community.to_dict()
            
            logger.info(f"Graph loaded from parquet: {len(self.graph.nodes())} nodes, {len(self.graph.edges())} edges")
            return True
            
        except Exception as e:
            logger.error(f"Failed to load from parquet: {e}")
            return False
    
    def detect_communities(self) -> Dict[str, int]:
        """
        Detect communities using Louvain algorithm
        Louvainアルゴリズムによるコミュニティ検出
        """
        if not COMMUNITY_AVAILABLE:
            logger.warning("Community detection not available. Install python-louvain")
            return {}
        
        try:
            partition = community_louvain.best_partition(self.graph)
            
            # Add community info to nodes
            for node in self.graph.nodes():
                self.graph.nodes[node]['community'] = partition.get(node, 0)
            
            logger.info(f"Detected {len(set(partition.values()))} communities")
            return partition
            
        except Exception as e:
            logger.error(f"Community detection failed: {e}")
            return {}
    
    def create_static_visualization(self, 
                                   output_path: str = "graphrag_static.png",
                                   figsize: Tuple[int, int] = (20, 16),
                                   node_size_multiplier: float = 300,
                                   show_labels: bool = True,
                                   layout: str = "spring") -> bool:
        """
        Create static visualization using NetworkX + Matplotlib
        NetworkX + Matplotlibによる静的視覚化
        """
        try:
            plt.figure(figsize=figsize)
            
            # Layout algorithms
            if layout == "spring":
                pos = nx.spring_layout(self.graph, k=3, iterations=50)
            elif layout == "circular":
                pos = nx.circular_layout(self.graph)
            elif layout == "kamada_kawai":
                pos = nx.kamada_kawai_layout(self.graph)
            elif layout == "spectral":
                pos = nx.spectral_layout(self.graph)
            else:
                pos = nx.spring_layout(self.graph)
            
            # Node colors by community
            communities = self.detect_communities()
            if communities:
                node_colors = [communities.get(node, 0) for node in self.graph.nodes()]
                cmap = plt.cm.Set3
            else:
                node_colors = 'lightblue'
                cmap = None
            
            # Node sizes by degree
            degrees = dict(self.graph.degree())
            node_sizes = [degrees.get(node, 1) * node_size_multiplier for node in self.graph.nodes()]
            
            # Draw the graph
            nx.draw_networkx_nodes(
                self.graph, pos,
                node_color=node_colors,
                node_size=node_sizes,
                cmap=cmap,
                alpha=0.8
            )
            
            nx.draw_networkx_edges(
                self.graph, pos,
                alpha=0.5,
                width=0.8,
                edge_color='gray'
            )
            
            if show_labels and len(self.graph.nodes()) < 100:
                # Only show labels for smaller graphs
                labels = {}
                for node in self.graph.nodes():
                    node_data = self.graph.nodes[node]
                    name = node_data.get('name', str(node))
                    if len(name) > 15:
                        name = name[:12] + "..."
                    labels[node] = name
                
                nx.draw_networkx_labels(
                    self.graph, pos,
                    labels,
                    font_size=8,
                    font_weight='bold'
                )
            
            plt.title(f"GraphRAG Knowledge Graph\n{len(self.graph.nodes())} entities, {len(self.graph.edges())} relationships", 
                     fontsize=16, fontweight='bold')
            plt.axis('off')
            plt.tight_layout()
            
            output_path = Path(output_path)
            plt.savefig(output_path, dpi=300, bbox_inches='tight')
            plt.close()
            
            logger.info(f"Static visualization saved to: {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"Static visualization failed: {e}")
            return False
    
    def create_interactive_visualization(self, 
                                        output_path: str = "graphrag_interactive.html",
                                        height: str = "800px",
                                        width: str = "100%",
                                        physics: bool = True) -> bool:
        """
        Create interactive visualization using Pyvis
        Pyvisによるインタラクティブ視覚化
        """
        if not PYVIS_AVAILABLE:
            logger.error("Pyvis not available. Install with: pip install pyvis")
            return False
        
        try:
            net = Network(height=height, width=width, bgcolor="#ffffff", font_color="black")
            
            if physics:
                net.set_options("""
                {
                  "physics": {
                    "enabled": true,
                    "stabilization": {"iterations": 100},
                    "barnesHut": {
                      "gravitationalConstant": -8000,
                      "springConstant": 0.001,
                      "springLength": 200
                    }
                  }
                }
                """)
            
            # Detect communities for coloring
            communities = self.detect_communities()
            
            # Color palette for communities
            colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', 
                     '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9']
            
            # Add nodes
            for node in self.graph.nodes():
                node_data = self.graph.nodes[node]
                name = node_data.get('name', str(node))
                node_type = node_data.get('type', 'Unknown')
                description = node_data.get('description', '')
                degree = self.graph.degree[node]
                community_id = communities.get(node, 0)
                
                # Node size based on degree
                size = min(max(degree * 5, 10), 50)
                
                # Node color based on community
                color = colors[community_id % len(colors)]
                
                # Create hover info
                title = f"""
                <b>{name}</b><br>
                Type: {node_type}<br>
                Connections: {degree}<br>
                Community: {community_id}<br>
                Description: {description[:200]}...
                """
                
                net.add_node(
                    node,
                    label=name,
                    title=title,
                    size=size,
                    color=color,
                    font={'size': 12, 'color': 'black'}
                )
            
            # Add edges
            for edge in self.graph.edges(data=True):
                source, target, data = edge
                relationship = data.get('relationship', '')
                weight = data.get('weight', 1.0)
                
                # Edge width based on weight
                width = min(max(weight * 2, 1), 8)
                
                net.add_edge(
                    source, 
                    target,
                    title=relationship,
                    width=width,
                    color={'color': 'gray', 'opacity': 0.6}
                )
            
            # Save interactive visualization
            net.show(output_path)
            
            logger.info(f"Interactive visualization saved to: {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"Interactive visualization failed: {e}")
            return False
    
    def create_community_analysis(self) -> Dict[str, Any]:
        """
        Analyze community structure
        コミュニティ構造の分析
        """
        communities = self.detect_communities()
        if not communities:
            return {}
        
        analysis = {
            'total_communities': len(set(communities.values())),
            'community_sizes': defaultdict(int),
            'community_entities': defaultdict(list),
            'modularity': 0.0
        }
        
        # Count community sizes and collect entities
        for node, community_id in communities.items():
            analysis['community_sizes'][community_id] += 1
            node_data = self.graph.nodes[node]
            analysis['community_entities'][community_id].append({
                'id': node,
                'name': node_data.get('name', str(node)),
                'type': node_data.get('type', 'Unknown'),
                'degree': self.graph.degree[node]
            })
        
        # Calculate modularity
        if COMMUNITY_AVAILABLE:
            try:
                analysis['modularity'] = community_louvain.modularity(communities, self.graph)
            except:
                pass
        
        return analysis
    
    def export_for_gephi(self, output_path: str = "graphrag_gephi.gexf") -> bool:
        """
        Export graph in GEXF format for Gephi
        Gephi用のGEXF形式でエクスポート
        """
        try:
            # Add community detection if not present
            if 'community' not in next(iter(self.graph.nodes(data=True)))[1]:
                self.detect_communities()
            
            nx.write_gexf(self.graph, output_path)
            logger.info(f"Graph exported for Gephi: {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"Gephi export failed: {e}")
            return False
    
    def generate_summary_report(self) -> Dict[str, Any]:
        """
        Generate comprehensive graph analysis report
        包括的なグラフ分析レポートの生成
        """
        report = {
            'basic_stats': {
                'nodes': len(self.graph.nodes()),
                'edges': len(self.graph.edges()),
                'density': nx.density(self.graph),
                'connected_components': nx.number_connected_components(self.graph)
            },
            'centrality': {
                'top_degree_nodes': [],
                'top_betweenness_nodes': [],
                'top_closeness_nodes': []
            },
            'community_analysis': self.create_community_analysis()
        }
        
        try:
            # Calculate centralities for top nodes
            degree_centrality = nx.degree_centrality(self.graph)
            betweenness_centrality = nx.betweenness_centrality(self.graph, k=min(100, len(self.graph.nodes())))
            closeness_centrality = nx.closeness_centrality(self.graph)
            
            # Get top 10 nodes for each centrality measure
            for centrality_dict, key in [(degree_centrality, 'top_degree_nodes'),
                                        (betweenness_centrality, 'top_betweenness_nodes'),
                                        (closeness_centrality, 'top_closeness_nodes')]:
                
                top_nodes = sorted(centrality_dict.items(), key=lambda x: x[1], reverse=True)[:10]
                report['centrality'][key] = [
                    {
                        'node': node,
                        'name': self.graph.nodes[node].get('name', str(node)),
                        'score': score
                    }
                    for node, score in top_nodes
                ]
        
        except Exception as e:
            logger.warning(f"Centrality calculation failed: {e}")
        
        return report

def create_comprehensive_visualization(output_dir: str = "./output") -> bool:
    """
    Create comprehensive GraphRAG visualization suite
    包括的なGraphRAG視覚化スイートの作成
    """
    visualizer = GraphRAGVisualizer(output_dir)
    
    print("GraphRAG Knowledge Graph Visualization Suite")
    print("=" * 60)
    
    # Step 1: Load data
    print("[1/6] Loading GraphRAG data...")
    if visualizer.load_graphml():
        print("   GraphML loaded successfully")
    elif visualizer.load_from_parquet():
        print("   Parquet data loaded successfully")
    else:
        print("   No graph data found")
        return False
    
    # Step 2: Generate analysis report
    print("[2/6] Analyzing graph structure...")
    report = visualizer.generate_summary_report()
    
    print(f"   Nodes: {report['basic_stats']['nodes']}")
    print(f"   Edges: {report['basic_stats']['edges']}")
    print(f"   Density: {report['basic_stats']['density']:.4f}")
    print(f"   Communities: {report['community_analysis'].get('total_communities', 'Unknown')}")
    
    # Step 3: Static visualization
    print("[3/6] Creating static visualization...")
    if visualizer.create_static_visualization():
        print("   Static visualization created: graphrag_static.png")
    
    # Step 4: Interactive visualization
    print("[4/6] Creating interactive visualization...")
    if visualizer.create_interactive_visualization():
        print("   Interactive visualization created: graphrag_interactive.html")
    
    # Step 5: Gephi export
    print("[5/6] Exporting for Gephi...")
    if visualizer.export_for_gephi():
        print("   Gephi file created: graphrag_gephi.gexf")
    
    # Step 6: Save analysis report
    print("[6/6] Saving analysis report...")
    report_path = Path(output_dir) / "visualization_report.json"
    with open(report_path, 'w', encoding='utf-8') as f:
        json.dump(report, f, indent=2, ensure_ascii=False)
    print(f"   Analysis report saved: {report_path}")
    
    print("\nVisualization suite completed!")
    print("\nGenerated files:")
    print("   * graphrag_static.png - Static network visualization")
    print("   * graphrag_interactive.html - Interactive web visualization")
    print("   * graphrag_gephi.gexf - Gephi-compatible format")
    print("   * visualization_report.json - Comprehensive analysis")
    
    return True

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="GraphRAG Knowledge Graph Visualization")
    parser.add_argument("--output-dir", default="./output", help="GraphRAG output directory")
    parser.add_argument("--static-only", action="store_true", help="Create only static visualization")
    parser.add_argument("--interactive-only", action="store_true", help="Create only interactive visualization")
    
    args = parser.parse_args()
    
    create_comprehensive_visualization(args.output_dir)